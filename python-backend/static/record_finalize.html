<!doctype html>
<meta charset="utf-8" />
<title>Save-only → Finalize(merge+STT)</title>
<style>
  body { font-family: system-ui, sans-serif; max-width: 860px; margin: 24px auto; line-height: 1.5; }
  button { padding: 8px 12px; margin-right: 8px; }
  input[type="number"] { width: 90px; }
  #log { white-space: pre-wrap; background:#f7f7f9; border:1px solid #ddd; padding:12px; border-radius:8px; }
  .row { display:flex; gap:8px; align-items:center; margin: 8px 0; flex-wrap: wrap; }
  .muted { color:#666; font-size: 12px; }
</style>

<h2>회의 중 저장 + 종료 후 병합/전사 테스트</h2>
<p class="muted">녹음 시작 → 5초마다 청크 업로드 → 정지 → 병합 → 전사</p>

<div class="row">
  <button id="start">녹음 시작</button>
  <button id="stop" disabled>정지</button>
  <button id="merge" disabled>병합</button>
  <button id="final" disabled>전사(종료)</button>
  <button id="reset">방 리셋</button>
  <label>room_no <input id="room" type="number" value="101"></label>
  <label>user_no <input id="user" type="number" value="1"></label>
</div>

<h3>로그</h3>
<pre id="log"></pre>

<script>
  const $start = document.getElementById('start');
  const $stop  = document.getElementById('stop');
  const $merge = document.getElementById('merge');
  const $final = document.getElementById('final');
  const $reset = document.getElementById('reset');
  const $room  = document.getElementById('room');
  const $user  = document.getElementById('user');
  const $log   = document.getElementById('log');

  const log = (...a) => ($log.textContent += a.join(' ') + '\n');

  let stream = null, running = false, seq = 0, startTs = 0;
  let merging = false, finalizing = false;

  function pickMime() {
    const cand = ['audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus','audio/ogg'];
    return cand.find(t => window.MediaRecorder && MediaRecorder.isTypeSupported(t)) || '';
  }

  function recordBlob(ms = 5000) {
    return new Promise((resolve, reject) => {
      try {
        const mimeType = pickMime();
        const mr = new MediaRecorder(
          stream,
          mimeType ? { mimeType, audioBitsPerSecond: 128000 } : { audioBitsPerSecond: 128000 }
        );
        const parts = [];
        mr.ondataavailable = e => { if (e.data && e.data.size) parts.push(e.data); };
        mr.onstop = () => resolve(new Blob(parts, { type: mr.mimeType || mimeType || 'audio/webm' }));
        mr.start();
        setTimeout(() => mr.stop(), ms);
      } catch (err) { reject(err); }
    });
  }

  async function uploadChunk(blob, s) {
    const form = new FormData();
    form.append('file', blob, `chunk-${s}.webm`);
    form.append('room_no', Number($room.value||0));
    form.append('user_no', Number($user.value||0));
    form.append('seq', s);
    form.append('ts_ms', Math.floor(startTs + s * 5000));
    const res = await fetch('/stt/chunk_raw', { method: 'POST', body: form });
    if (!res.ok) throw new Error(await res.text());
    const j = await res.json();
    log(`✅ 청크 ${s} 저장 (bytes=${j.bytes}) + 선변환(wav=${j.wav_preconverted})`);
  }

  async function loop() {
    while (running) {
      const s = seq++;
      try {
        const blob = await recordBlob(5000);
        await uploadChunk(blob, s);
      } catch (e) {
        log('❌ 업로드 실패:', String(e));
      }
      await new Promise(r => setTimeout(r, 10));
    }
  }

  function setRecordingUI(on) {
    $start.disabled = on;
    $stop.disabled  = !on;
    $merge.disabled = on;
    $final.disabled = on;
    $room.disabled  = on;
    $user.disabled  = on;
  }

  $start.onclick = async () => {
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          channelCount: 1,
          sampleRate: 48000,
          noiseSuppression: false,
          echoCancellation: false,
          autoGainControl: false
        }
      });
      running = true; seq = 0; startTs = performance.now();
      setRecordingUI(true);
      log('🎙️ 녹음 시작 (5초 단위 저장)…');
      loop();
    } catch (e) {
      log('마이크 오류:', String(e));
    }
  };

  $stop.onclick = async () => {
    running = false;
    if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
    setRecordingUI(false);
    $merge.disabled = false;
    $final.disabled = false;
    log('⏹️ 정지. 병합 또는 전사를 눌러주세요.');
  };

  $merge.onclick = async () => {
    if (merging) return;
    merging = true;
    $merge.disabled = true; $final.disabled = true; $start.disabled = true;
    try {
      const res = await fetch(`/stt/merge_room?room_no=${Number($room.value||0)}`, { method: 'POST' });
      const t = await res.text();
      log('— 병합 응답 —\n' + t);
    } catch (e) {
      log('❌ 병합 실패:', String(e));
    } finally {
      merging = false;
      $merge.disabled = false; $final.disabled = false; $start.disabled = false;
    }
  };

  $final.onclick = async () => {
    if (finalizing) return;
    finalizing = true;
    $merge.disabled = true; $final.disabled = true; $start.disabled = true;
    try {
      const res = await fetch(`/stt/finalize_room?room_no=${Number($room.value||0)}`, { method: 'POST' });
      const t = await res.text();
      log('— 전사 응답 —\n' + t);
    } catch (e) {
      log('❌ 전사 실패:', String(e));
    } finally {
      finalizing = false;
      $merge.disabled = false; $final.disabled = false; $start.disabled = false;
    }
  };

  $reset.onclick = async () => {
    if (running) { log('⚠️ 녹음 중에는 리셋할 수 없습니다. 먼저 정지하세요.'); return; }
    const room = Number($room.value||0);
    try {
      const res = await fetch(`/stt/reset_room?room_no=${room}`, { method: 'DELETE' });
      const t = await res.text();
      log('🧹 방 리셋 응답:\n' + t);
    } catch (e) {
      log('❌ 리셋 실패:', String(e));
    }
  };
</script>
