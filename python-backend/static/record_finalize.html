<!doctype html>
<meta charset="utf-8" />
<title>Save-only â†’ Finalize(merge+STT)</title>
<style>
  body { font-family: system-ui, sans-serif; max-width: 860px; margin: 24px auto; line-height: 1.5; }
  button { padding: 8px 12px; margin-right: 8px; }
  input[type="number"] { width: 90px; }
  #log { white-space: pre-wrap; background:#f7f7f9; border:1px solid #ddd; padding:12px; border-radius:8px; }
  .row { display:flex; gap:8px; align-items:center; margin: 8px 0; flex-wrap: wrap; }
  .muted { color:#666; font-size: 12px; }
</style>

<h2>íšŒì˜ ì¤‘ ì €ì¥ + ì¢…ë£Œ í›„ ë³‘í•©/ì „ì‚¬ í…ŒìŠ¤íŠ¸</h2>
<p class="muted">ë…¹ìŒ ì‹œì‘ â†’ 5ì´ˆë§ˆë‹¤ ì²­í¬ ì—…ë¡œë“œ â†’ ì •ì§€ â†’ ë³‘í•© â†’ ì „ì‚¬</p>

<div class="row">
  <button id="start">ë…¹ìŒ ì‹œì‘</button>
  <button id="stop" disabled>ì •ì§€</button>
  <button id="merge" disabled>ë³‘í•©</button>
  <button id="final" disabled>ì „ì‚¬(ì¢…ë£Œ)</button>
  <button id="reset">ë°© ë¦¬ì…‹</button>
  <label>room_no <input id="room" type="number" value="101"></label>
  <label>user_no <input id="user" type="number" value="1"></label>
</div>

<h3>ë¡œê·¸</h3>
<pre id="log"></pre>

<script>
  const $start = document.getElementById('start');
  const $stop  = document.getElementById('stop');
  const $merge = document.getElementById('merge');
  const $final = document.getElementById('final');
  const $reset = document.getElementById('reset');
  const $room  = document.getElementById('room');
  const $user  = document.getElementById('user');
  const $log   = document.getElementById('log');

  const log = (...a) => ($log.textContent += a.join(' ') + '\n');

  let stream = null, running = false, seq = 0, startTs = 0;
  let merging = false, finalizing = false;

  function pickMime() {
    const cand = ['audio/webm;codecs=opus','audio/webm','audio/ogg;codecs=opus','audio/ogg'];
    return cand.find(t => window.MediaRecorder && MediaRecorder.isTypeSupported(t)) || '';
  }

  function recordBlob(ms = 5000) {
    return new Promise((resolve, reject) => {
      try {
        const mimeType = pickMime();
        const mr = new MediaRecorder(
          stream,
          mimeType ? { mimeType, audioBitsPerSecond: 128000 } : { audioBitsPerSecond: 128000 }
        );
        const parts = [];
        mr.ondataavailable = e => { if (e.data && e.data.size) parts.push(e.data); };
        mr.onstop = () => resolve(new Blob(parts, { type: mr.mimeType || mimeType || 'audio/webm' }));
        mr.start();
        setTimeout(() => mr.stop(), ms);
      } catch (err) { reject(err); }
    });
  }

  async function uploadChunk(blob, s) {
    const form = new FormData();
    form.append('file', blob, `chunk-${s}.webm`);
    form.append('room_no', Number($room.value||0));
    form.append('user_no', Number($user.value||0));
    form.append('seq', s);
    form.append('ts_ms', Math.floor(startTs + s * 5000));
    const res = await fetch('/stt/chunk_raw', { method: 'POST', body: form });
    if (!res.ok) throw new Error(await res.text());
    const j = await res.json();
    log(`âœ… ì²­í¬ ${s} ì €ì¥ (bytes=${j.bytes}) + ì„ ë³€í™˜(wav=${j.wav_preconverted})`);
  }

  async function loop() {
    while (running) {
      const s = seq++;
      try {
        const blob = await recordBlob(5000);
        await uploadChunk(blob, s);
      } catch (e) {
        log('âŒ ì—…ë¡œë“œ ì‹¤íŒ¨:', String(e));
      }
      await new Promise(r => setTimeout(r, 10));
    }
  }

  function setRecordingUI(on) {
    $start.disabled = on;
    $stop.disabled  = !on;
    $merge.disabled = on;
    $final.disabled = on;
    $room.disabled  = on;
    $user.disabled  = on;
  }

  $start.onclick = async () => {
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          channelCount: 1,
          sampleRate: 48000,
          noiseSuppression: false,
          echoCancellation: false,
          autoGainControl: false
        }
      });
      running = true; seq = 0; startTs = performance.now();
      setRecordingUI(true);
      log('ğŸ™ï¸ ë…¹ìŒ ì‹œì‘ (5ì´ˆ ë‹¨ìœ„ ì €ì¥)â€¦');
      loop();
    } catch (e) {
      log('ë§ˆì´í¬ ì˜¤ë¥˜:', String(e));
    }
  };

  $stop.onclick = async () => {
    running = false;
    if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
    setRecordingUI(false);
    $merge.disabled = false;
    $final.disabled = false;
    log('â¹ï¸ ì •ì§€. ë³‘í•© ë˜ëŠ” ì „ì‚¬ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”.');
  };

  $merge.onclick = async () => {
    if (merging) return;
    merging = true;
    $merge.disabled = true; $final.disabled = true; $start.disabled = true;
    try {
      const res = await fetch(`/stt/merge_room?room_no=${Number($room.value||0)}`, { method: 'POST' });
      const t = await res.text();
      log('â€” ë³‘í•© ì‘ë‹µ â€”\n' + t);
    } catch (e) {
      log('âŒ ë³‘í•© ì‹¤íŒ¨:', String(e));
    } finally {
      merging = false;
      $merge.disabled = false; $final.disabled = false; $start.disabled = false;
    }
  };

  $final.onclick = async () => {
    if (finalizing) return;
    finalizing = true;
    $merge.disabled = true; $final.disabled = true; $start.disabled = true;
    try {
      const res = await fetch(`/stt/finalize_room?room_no=${Number($room.value||0)}`, { method: 'POST' });
      const t = await res.text();
      log('â€” ì „ì‚¬ ì‘ë‹µ â€”\n' + t);
    } catch (e) {
      log('âŒ ì „ì‚¬ ì‹¤íŒ¨:', String(e));
    } finally {
      finalizing = false;
      $merge.disabled = false; $final.disabled = false; $start.disabled = false;
    }
  };

  $reset.onclick = async () => {
    if (running) { log('âš ï¸ ë…¹ìŒ ì¤‘ì—ëŠ” ë¦¬ì…‹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ì •ì§€í•˜ì„¸ìš”.'); return; }
    const room = Number($room.value||0);
    try {
      const res = await fetch(`/stt/reset_room?room_no=${room}`, { method: 'DELETE' });
      const t = await res.text();
      log('ğŸ§¹ ë°© ë¦¬ì…‹ ì‘ë‹µ:\n' + t);
    } catch (e) {
      log('âŒ ë¦¬ì…‹ ì‹¤íŒ¨:', String(e));
    }
  };
</script>
